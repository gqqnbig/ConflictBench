Found the following features in expression file:
left
base
right
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/20_Conflicts/workspace/left/src/main/java/io/socket/parser/Parser.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/20_Conflicts/workspace/left/src/main/java/io/socket/parser/Parser.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/20_Conflicts/workspace/base/src/main/java/io/socket/parser/Parser.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/20_Conflicts/workspace/base/src/main/java/io/socket/parser/Parser.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/20_Conflicts/workspace/right/src/main/java/io/socket/parser/Parser.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/20_Conflicts/workspace/right/src/main/java/io/socket/parser/Parser.java
[NT -> left : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> io : Folder]
					[NT -> socket : Folder]
						[NT -> parser : Folder]
							[NT -> Parser.java : Java-File]
								[NT -> - : CompilationUnit]
									[T -> - : PackageDeclaration "package io.socket.parser;" compose:Replacement merge: Default]
									[T -> io.socket.emitter.Emitter{ImportPackage} : ImportDeclaration "import io.socket.emitter.Emitter;" compose:Replacement merge: Default]
									[T -> io.socket.hasbinary.HasBinary{ImportPackage} : ImportDeclaration "import io.socket.hasbinary.HasBinary;" compose:Replacement merge: Default]
									[T -> org.json.JSONException{ImportPackage} : ImportDeclaration "import org.json.JSONException;" compose:Replacement merge: Default]
									[T -> org.json.JSONTokener{ImportPackage} : ImportDeclaration "import org.json.JSONTokener;" compose:Replacement merge: Default]
									[T -> java.util.ArrayList{ImportPackage} : ImportDeclaration "import java.util.ArrayList;" compose:Replacement merge: Default]
									[T -> java.util.Arrays{ImportPackage} : ImportDeclaration "import java.util.Arrays;" compose:Replacement merge: Default]
									[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: Default]
									[T -> java.util.logging.Level{ImportPackage} : ImportDeclaration "import java.util.logging.Level;" compose:Replacement merge: Default]
									[T -> java.util.logging.Logger{ImportPackage} : ImportDeclaration "import java.util.logging.Logger;" compose:Replacement merge: Default]
									[NT -> Parser : ClassDeclaration]
										[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
										[T -> - : ClassOrInterface2 "interface" compose:Replacement merge: Default]
										[T -> Parser : Id "Parser" compose:Replacement merge: Default]
										[T -> CONNECT : FieldDecl "public static final int CONNECT = 0;" compose:Replacement merge: SemanticConflict]
										[T -> DISCONNECT : FieldDecl "public static final int DISCONNECT = 1;" compose:Replacement merge: SemanticConflict]
										[T -> EVENT : FieldDecl "public static final int EVENT = 2;" compose:Replacement merge: SemanticConflict]
										[T -> ACK : FieldDecl "public static final int ACK = 3;" compose:Replacement merge: SemanticConflict]
										[T -> ERROR : FieldDecl "public static final int ERROR = 4;" compose:Replacement merge: SemanticConflict]
										[T -> BINARY_EVENT : FieldDecl "public static final int BINARY_EVENT = 5;" compose:Replacement merge: SemanticConflict]
										[T -> BINARY_ACK : FieldDecl "public static final int BINARY_ACK = 6;" compose:Replacement merge: SemanticConflict]
										[T -> protocol : FieldDecl "public static int protocol = 4;" compose:Replacement merge: SemanticConflict]
										[T -> types : FieldDecl "public static String[] types = new String[] {         "CONNECT",         "DISCONNECT",         "EVENT",         "ACK",         "ERROR",         "BINARY_EVENT",         "BINARY_ACK"     };" compose:Replacement merge: SemanticConflict]
										[NT -> Encoder : InnerClassDecl]
											[T -> - : Modifiers "public static" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface2 "interface" compose:Replacement merge: Default]
											[T -> Encoder : Id "Encoder" compose:Replacement merge: Default]
											[T -> encode(Packet-Packet-Callback-Callback) : MethodDecl "public void encode(Packet obj, Callback callback);" compose:Replacement merge: LineBased]
											[NT -> Callback : InnerClassDecl]
												[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
												[T -> - : ClassOrInterface2 "interface" compose:Replacement merge: Default]
												[T -> Callback : Id "Callback" compose:Replacement merge: Default]
												[T -> call(Object[]-Object[]) : MethodDecl "public void call(Object[] data);" compose:Replacement merge: LineBased]
										[NT -> Decoder : InnerClassDecl]
											[T -> - : Modifiers "public static" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface2 "interface" compose:Replacement merge: Default]
											[T -> Decoder : Id "Decoder" compose:Replacement merge: Default]
											[T -> add(String-String) : MethodDecl "public void add(String obj);" compose:Replacement merge: LineBased]
											[T -> add(byte[]-byte[]) : MethodDecl "public void add(byte[] obj);" compose:Replacement merge: LineBased]
											[T -> destroy({FormalParametersInternal}) : MethodDecl "public void destroy();" compose:Replacement merge: LineBased]
											[T -> onDecoded(Callback-Callback) : MethodDecl "public void onDecoded(Callback callback);" compose:Replacement merge: LineBased]
											[NT -> Callback : InnerClassDecl]
												[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
												[T -> - : ClassOrInterface2 "interface" compose:Replacement merge: Default]
												[T -> Callback : Id "Callback" compose:Replacement merge: Default]
												[T -> call(Packet-Packet) : MethodDecl "public void call(Packet packet);" compose:Replacement merge: LineBased]
[NT -> base : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> io : Folder]
					[NT -> socket : Folder]
						[NT -> parser : Folder]
							[NT -> Parser.java : Java-File]
								[NT -> - : CompilationUnit]
									[T -> - : PackageDeclaration "package io.socket.parser;" compose:Replacement merge: Default]
									[T -> io.socket.emitter.Emitter{ImportPackage} : ImportDeclaration "import io.socket.emitter.Emitter;" compose:Replacement merge: Default]
									[T -> org.json.JSONException{ImportPackage} : ImportDeclaration "import org.json.JSONException;" compose:Replacement merge: Default]
									[T -> org.json.JSONTokener{ImportPackage} : ImportDeclaration "import org.json.JSONTokener;" compose:Replacement merge: Default]
									[T -> java.util.ArrayList{ImportPackage} : ImportDeclaration "import java.util.ArrayList;" compose:Replacement merge: Default]
									[T -> java.util.Arrays{ImportPackage} : ImportDeclaration "import java.util.Arrays;" compose:Replacement merge: Default]
									[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: Default]
									[T -> java.util.logging.Level{ImportPackage} : ImportDeclaration "import java.util.logging.Level;" compose:Replacement merge: Default]
									[T -> java.util.logging.Logger{ImportPackage} : ImportDeclaration "import java.util.logging.Logger;" compose:Replacement merge: Default]
									[NT -> Parser : ClassDeclaration]
										[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
										[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
										[T -> Parser : Id "Parser" compose:Replacement merge: Default]
										[T -> logger : FieldDecl "private static final Logger logger = Logger.getLogger(Parser.class.getName());" compose:Replacement merge: SemanticConflict]
										[T -> CONNECT : FieldDecl "public static final int CONNECT = 0;" compose:Replacement merge: SemanticConflict]
										[T -> DISCONNECT : FieldDecl "public static final int DISCONNECT = 1;" compose:Replacement merge: SemanticConflict]
										[T -> EVENT : FieldDecl "public static final int EVENT = 2;" compose:Replacement merge: SemanticConflict]
										[T -> ACK : FieldDecl "public static final int ACK = 3;" compose:Replacement merge: SemanticConflict]
										[T -> ERROR : FieldDecl "public static final int ERROR = 4;" compose:Replacement merge: SemanticConflict]
										[T -> BINARY_EVENT : FieldDecl "public static final int BINARY_EVENT = 5;" compose:Replacement merge: SemanticConflict]
										[T -> BINARY_ACK : FieldDecl "public static final int BINARY_ACK = 6;" compose:Replacement merge: SemanticConflict]
										[T -> protocol : FieldDecl "public static int protocol = 4;" compose:Replacement merge: SemanticConflict]
										[T -> types : FieldDecl "public static String[] types = new String[] {         "CONNECT",         "DISCONNECT",         "EVENT",         "ACK",         "ERROR",         "BINARY_EVENT",         "BINARY_ACK"     };" compose:Replacement merge: SemanticConflict]
										[T -> Parser({FormalParametersInternal}) : ConstructorDecl "private Parser() {}" compose:Replacement merge: LineBased]
										[T -> error({FormalParametersInternal}) : MethodDecl "private static Packet<String> error() {         return new Packet<String>(ERROR, "parser error");     }" compose:Replacement merge: LineBased]
										[NT -> Encoder : InnerClassDecl]
											[T -> - : Modifiers "public static" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
											[T -> Encoder : Id "Encoder" compose:Replacement merge: Default]
											[T -> Encoder({FormalParametersInternal}) : ConstructorDecl "public Encoder() {}" compose:Replacement merge: LineBased]
											[T -> encode(Packet-Packet-Callback-Callback) : MethodDecl "public void encode(Packet obj, Callback callback) {             logger.fine(String.format("encoding packet %s", obj));              if (BINARY_EVENT == obj.type || BINARY_ACK == obj.type) {                 encodeAsBinary(obj, callback);             } else {                 String encoding = encodeAsString(obj);                 callback.call(new String[] {encoding});             }         }" compose:Replacement merge: LineBased]
											[T -> encodeAsString(Packet-Packet) : MethodDecl "private String encodeAsString(Packet obj) {             StringBuilder str = new StringBuilder();             boolean nsp = false;              str.append(obj.type);              if (BINARY_EVENT == obj.type || BINARY_ACK == obj.type) {                 str.append(obj.attachments);                 str.append("-");             }              if (obj.nsp != null && obj.nsp.length() != 0 && !"/".equals(obj.nsp)) {                 nsp = true;                 str.append(obj.nsp);             }              if (obj.id >= 0) {                 if (nsp) {                     str.append(",");                     nsp = false;                 }                 str.append(obj.id);             }              if (obj.data != null) {                 if (nsp) str.append(",");                 str.append(obj.data);             }              logger.fine(String.format("encoded %s as %s", obj, str));             return str.toString();         }" compose:Replacement merge: LineBased]
											[T -> encodeAsBinary(Packet-Packet-Callback-Callback) : MethodDecl "private void encodeAsBinary(Packet obj, Callback callback) {             Binary.DeconstructedPacket deconstruction = Binary.deconstructPacket(obj);             String pack = encodeAsString(deconstruction.packet);             List<Object> buffers = new ArrayList<Object>(Arrays.asList(deconstruction.buffers));              buffers.add(0, pack);             callback.call(buffers.toArray());         }" compose:Replacement merge: LineBased]
											[NT -> Callback : InnerClassDecl]
												[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
												[T -> - : ClassOrInterface2 "interface" compose:Replacement merge: Default]
												[T -> Callback : Id "Callback" compose:Replacement merge: Default]
												[T -> call(Object[]-Object[]) : MethodDecl "public void call(Object[] data);" compose:Replacement merge: LineBased]
										[NT -> Decoder : InnerClassDecl]
											[T -> - : Modifiers "public static" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
											[T -> Decoder : Id "Decoder" compose:Replacement merge: Default]
											[T -> - : ExtendsList "extends Emitter" compose:Replacement merge: Default]
											[T -> EVENT_DECODED : FieldDecl "public static String EVENT_DECODED = "decoded";" compose:Replacement merge: SemanticConflict]
											[T -> reconstructor : FieldDecl "BinaryReconstructor reconstructor;" compose:Replacement merge: SemanticConflict]
											[T -> Decoder({FormalParametersInternal}) : ConstructorDecl "public Decoder() {             this.reconstructor = null;         }" compose:Replacement merge: LineBased]
											[T -> add(String-String) : MethodDecl "public void add(String obj) {             Packet packet = decodeString(obj);             if (BINARY_EVENT == packet.type || BINARY_ACK == packet.type) {                 this.reconstructor = new BinaryReconstructor(packet);                  if (this.reconstructor.reconPack.attachments == 0) {                     this.emit(EVENT_DECODED, packet);                 }             } else {                 this.emit(EVENT_DECODED, packet);             }         }" compose:Replacement merge: LineBased]
											[T -> add(byte[]-byte[]) : MethodDecl "public void add(byte[] obj) {             if (this.reconstructor == null) {                 throw new RuntimeException("got binary data when not reconstructing a packet");             } else {                 Packet packet = this.reconstructor.takeBinaryData(obj);                 if (packet != null) {                     this.reconstructor = null;                     this.emit(EVENT_DECODED, packet);                 }             }         }" compose:Replacement merge: LineBased]
											[T -> decodeString(String-String) : MethodDecl "private static Packet decodeString(String str) {             Packet<Object> p = new Packet<Object>();             int i = 0;             int length = str.length();              p.type = Character.getNumericValue(str.charAt(0));             if (p.type < 0 || p.type > types.length - 1) return error();              if (BINARY_EVENT == p.type || BINARY_ACK == p.type) {                 if (!str.contains("-") || length <= i + 1) return error();                 StringBuilder attachments = new StringBuilder();                 while (str.charAt(++i) != '-') {                     attachments.append(str.charAt(i));                 }                 p.attachments = Integer.parseInt(attachments.toString());             }              if (length > i + 1 && '/' == str.charAt(i + 1)) {                 StringBuilder nsp = new StringBuilder();                 while (true) {                     ++i;                     char c = str.charAt(i);                     if (',' == c) break;                     nsp.append(c);                     if (i + 1 == length) break;                 }                 p.nsp = nsp.toString();             } else {                 p.nsp = "/";             }              if (length > i + 1){                 Character next = str.charAt(i + 1);                 if (Character.getNumericValue(next) > -1) {                     StringBuilder id = new StringBuilder();                     while (true) {                         ++i;                         char c = str.charAt(i);                         if (Character.getNumericValue(c) < 0) {                             --i;                             break;                         }                         id.append(c);                         if (i + 1 == length) break;                     }                     try {                         p.id = Integer.parseInt(id.toString());                     } catch (NumberFormatException e){                         return error();                     }                 }             }              if (length > i + 1){                 try {                     str.charAt(++i);                     p.data = new JSONTokener(str.substring(i)).nextValue();                 } catch (JSONException e) {                     logger.log(Level.WARNING, "An error occured while retrieving data from JSONTokener", e);                     return error();                 }             }              logger.fine(String.format("decoded %s as %s", str, p));             return p;         }" compose:Replacement merge: LineBased]
											[T -> destroy({FormalParametersInternal}) : MethodDecl "public void destroy() {             if (this.reconstructor != null) {                 this.reconstructor.finishReconstruction();             }         }" compose:Replacement merge: LineBased]
										[NT -> BinaryReconstructor : InnerClassDecl]
											[T -> - : Modifiers "static" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
											[T -> BinaryReconstructor : Id "BinaryReconstructor" compose:Replacement merge: Default]
											[T -> reconPack : FieldDecl "public Packet reconPack;" compose:Replacement merge: SemanticConflict]
											[T -> buffers : FieldDecl "List<byte[]> buffers;" compose:Replacement merge: SemanticConflict]
											[T -> BinaryReconstructor(Packet-Packet) : ConstructorDecl "BinaryReconstructor(Packet packet) {             this.reconPack = packet;             this.buffers = new ArrayList<byte[]>();         }" compose:Replacement merge: LineBased]
											[T -> takeBinaryData(byte[]-byte[]) : MethodDecl "public Packet takeBinaryData(byte[] binData) {             this.buffers.add(binData);             if (this.buffers.size() == this.reconPack.attachments) {                 Packet packet = Binary.reconstructPacket(this.reconPack,                         this.buffers.toArray(new byte[this.buffers.size()][]));                 this.finishReconstruction();                 return packet;             }             return null;         }" compose:Replacement merge: LineBased]
											[T -> finishReconstruction({FormalParametersInternal}) : MethodDecl "public void finishReconstruction () {             this.reconPack = null;             this.buffers = new ArrayList<byte[]>();         }" compose:Replacement merge: LineBased]
[NT -> right : Feature]
	[NT -> src : Folder]
		[NT -> main : Folder]
			[NT -> java : Folder]
				[NT -> io : Folder]
					[NT -> socket : Folder]
						[NT -> parser : Folder]
							[NT -> Parser.java : Java-File]
								[NT -> - : CompilationUnit]
									[T -> - : PackageDeclaration "package io.socket.parser;" compose:Replacement merge: Default]
									[T -> io.socket.emitter.Emitter{ImportPackage} : ImportDeclaration "import io.socket.emitter.Emitter;" compose:Replacement merge: Default]
									[T -> org.json.JSONException{ImportPackage} : ImportDeclaration "import org.json.JSONException;" compose:Replacement merge: Default]
									[T -> org.json.JSONTokener{ImportPackage} : ImportDeclaration "import org.json.JSONTokener;" compose:Replacement merge: Default]
									[T -> java.util.ArrayList{ImportPackage} : ImportDeclaration "import java.util.ArrayList;" compose:Replacement merge: Default]
									[T -> java.util.Arrays{ImportPackage} : ImportDeclaration "import java.util.Arrays;" compose:Replacement merge: Default]
									[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: Default]
									[T -> java.util.logging.Level{ImportPackage} : ImportDeclaration "import java.util.logging.Level;" compose:Replacement merge: Default]
									[T -> java.util.logging.Logger{ImportPackage} : ImportDeclaration "import java.util.logging.Logger;" compose:Replacement merge: Default]
									[NT -> Parser : ClassDeclaration]
										[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
										[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
										[T -> Parser : Id "Parser" compose:Replacement merge: Default]
										[T -> logger : FieldDecl "private static final Logger logger = Logger.getLogger(Parser.class.getName());" compose:Replacement merge: SemanticConflict]
										[T -> CONNECT : FieldDecl "public static final int CONNECT = 0;" compose:Replacement merge: SemanticConflict]
										[T -> DISCONNECT : FieldDecl "public static final int DISCONNECT = 1;" compose:Replacement merge: SemanticConflict]
										[T -> EVENT : FieldDecl "public static final int EVENT = 2;" compose:Replacement merge: SemanticConflict]
										[T -> ACK : FieldDecl "public static final int ACK = 3;" compose:Replacement merge: SemanticConflict]
										[T -> ERROR : FieldDecl "public static final int ERROR = 4;" compose:Replacement merge: SemanticConflict]
										[T -> BINARY_EVENT : FieldDecl "public static final int BINARY_EVENT = 5;" compose:Replacement merge: SemanticConflict]
										[T -> BINARY_ACK : FieldDecl "public static final int BINARY_ACK = 6;" compose:Replacement merge: SemanticConflict]
										[T -> protocol : FieldDecl "public static int protocol = 4;" compose:Replacement merge: SemanticConflict]
										[T -> types : FieldDecl "public static String[] types = new String[] {         "CONNECT",         "DISCONNECT",         "EVENT",         "ACK",         "ERROR",         "BINARY_EVENT",         "BINARY_ACK"     };" compose:Replacement merge: SemanticConflict]
										[T -> Parser({FormalParametersInternal}) : ConstructorDecl "private Parser() {}" compose:Replacement merge: LineBased]
										[T -> error({FormalParametersInternal}) : MethodDecl "private static Packet<String> error() {         return new Packet<String>(ERROR, "parser error");     }" compose:Replacement merge: LineBased]
										[NT -> Encoder : InnerClassDecl]
											[T -> - : Modifiers "public static" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
											[T -> Encoder : Id "Encoder" compose:Replacement merge: Default]
											[T -> Encoder({FormalParametersInternal}) : ConstructorDecl "public Encoder() {}" compose:Replacement merge: LineBased]
											[T -> encode(Packet-Packet-Callback-Callback) : MethodDecl "public void encode(Packet obj, Callback callback) {             if (logger.isLoggable(Level.FINE)) {                 logger.fine(String.format("encoding packet %s", obj));             }              if (BINARY_EVENT == obj.type || BINARY_ACK == obj.type) {                 encodeAsBinary(obj, callback);             } else {                 String encoding = encodeAsString(obj);                 callback.call(new String[] {encoding});             }         }" compose:Replacement merge: LineBased]
											[T -> encodeAsString(Packet-Packet) : MethodDecl "private String encodeAsString(Packet obj) {             StringBuilder str = new StringBuilder();             boolean nsp = false;              str.append(obj.type);              if (BINARY_EVENT == obj.type || BINARY_ACK == obj.type) {                 str.append(obj.attachments);                 str.append("-");             }              if (obj.nsp != null && obj.nsp.length() != 0 && !"/".equals(obj.nsp)) {                 nsp = true;                 str.append(obj.nsp);             }              if (obj.id >= 0) {                 if (nsp) {                     str.append(",");                     nsp = false;                 }                 str.append(obj.id);             }              if (obj.data != null) {                 if (nsp) str.append(",");                 str.append(obj.data);             }              if (logger.isLoggable(Level.FINE)) {                 logger.fine(String.format("encoded %s as %s", obj, str));             }             return str.toString();         }" compose:Replacement merge: LineBased]
											[T -> encodeAsBinary(Packet-Packet-Callback-Callback) : MethodDecl "private void encodeAsBinary(Packet obj, Callback callback) {             Binary.DeconstructedPacket deconstruction = Binary.deconstructPacket(obj);             String pack = encodeAsString(deconstruction.packet);             List<Object> buffers = new ArrayList<Object>(Arrays.asList(deconstruction.buffers));              buffers.add(0, pack);             callback.call(buffers.toArray());         }" compose:Replacement merge: LineBased]
											[NT -> Callback : InnerClassDecl]
												[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
												[T -> - : ClassOrInterface2 "interface" compose:Replacement merge: Default]
												[T -> Callback : Id "Callback" compose:Replacement merge: Default]
												[T -> call(Object[]-Object[]) : MethodDecl "public void call(Object[] data);" compose:Replacement merge: LineBased]
										[NT -> Decoder : InnerClassDecl]
											[T -> - : Modifiers "public static" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
											[T -> Decoder : Id "Decoder" compose:Replacement merge: Default]
											[T -> - : ExtendsList "extends Emitter" compose:Replacement merge: Default]
											[T -> EVENT_DECODED : FieldDecl "public static String EVENT_DECODED = "decoded";" compose:Replacement merge: SemanticConflict]
											[T -> reconstructor : FieldDecl "BinaryReconstructor reconstructor;" compose:Replacement merge: SemanticConflict]
											[T -> Decoder({FormalParametersInternal}) : ConstructorDecl "public Decoder() {             this.reconstructor = null;         }" compose:Replacement merge: LineBased]
											[T -> add(String-String) : MethodDecl "public void add(String obj) {             Packet packet = decodeString(obj);             if (BINARY_EVENT == packet.type || BINARY_ACK == packet.type) {                 this.reconstructor = new BinaryReconstructor(packet);                  if (this.reconstructor.reconPack.attachments == 0) {                     this.emit(EVENT_DECODED, packet);                 }             } else {                 this.emit(EVENT_DECODED, packet);             }         }" compose:Replacement merge: LineBased]
											[T -> add(byte[]-byte[]) : MethodDecl "public void add(byte[] obj) {             if (this.reconstructor == null) {                 throw new RuntimeException("got binary data when not reconstructing a packet");             } else {                 Packet packet = this.reconstructor.takeBinaryData(obj);                 if (packet != null) {                     this.reconstructor = null;                     this.emit(EVENT_DECODED, packet);                 }             }         }" compose:Replacement merge: LineBased]
											[T -> decodeString(String-String) : MethodDecl "private static Packet decodeString(String str) {             Packet<Object> p = new Packet<Object>();             int i = 0;             int length = str.length();              p.type = Character.getNumericValue(str.charAt(0));             if (p.type < 0 || p.type > types.length - 1) return error();              if (BINARY_EVENT == p.type || BINARY_ACK == p.type) {                 if (!str.contains("-") || length <= i + 1) return error();                 StringBuilder attachments = new StringBuilder();                 while (str.charAt(++i) != '-') {                     attachments.append(str.charAt(i));                 }                 p.attachments = Integer.parseInt(attachments.toString());             }              if (length > i + 1 && '/' == str.charAt(i + 1)) {                 StringBuilder nsp = new StringBuilder();                 while (true) {                     ++i;                     char c = str.charAt(i);                     if (',' == c) break;                     nsp.append(c);                     if (i + 1 == length) break;                 }                 p.nsp = nsp.toString();             } else {                 p.nsp = "/";             }              if (length > i + 1){                 Character next = str.charAt(i + 1);                 if (Character.getNumericValue(next) > -1) {                     StringBuilder id = new StringBuilder();                     while (true) {                         ++i;                         char c = str.charAt(i);                         if (Character.getNumericValue(c) < 0) {                             --i;                             break;                         }                         id.append(c);                         if (i + 1 == length) break;                     }                     try {                         p.id = Integer.parseInt(id.toString());                     } catch (NumberFormatException e){                         return error();                     }                 }             }              if (length > i + 1){                 try {                     str.charAt(++i);                     p.data = new JSONTokener(str.substring(i)).nextValue();                 } catch (JSONException e) {                     logger.log(Level.WARNING, "An error occured while retrieving data from JSONTokener", e);                     return error();                 }             }              if (logger.isLoggable(Level.FINE)) {                 logger.fine(String.format("decoded %s as %s", str, p));             }             return p;         }" compose:Replacement merge: LineBased]
											[T -> destroy({FormalParametersInternal}) : MethodDecl "public void destroy() {             if (this.reconstructor != null) {                 this.reconstructor.finishReconstruction();             }         }" compose:Replacement merge: LineBased]
										[NT -> BinaryReconstructor : InnerClassDecl]
											[T -> - : Modifiers "static" compose:Replacement merge: SemanticConflict]
											[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
											[T -> BinaryReconstructor : Id "BinaryReconstructor" compose:Replacement merge: Default]
											[T -> reconPack : FieldDecl "public Packet reconPack;" compose:Replacement merge: SemanticConflict]
											[T -> buffers : FieldDecl "List<byte[]> buffers;" compose:Replacement merge: SemanticConflict]
											[T -> BinaryReconstructor(Packet-Packet) : ConstructorDecl "BinaryReconstructor(Packet packet) {             this.reconPack = packet;             this.buffers = new ArrayList<byte[]>();         }" compose:Replacement merge: LineBased]
											[T -> takeBinaryData(byte[]-byte[]) : MethodDecl "public Packet takeBinaryData(byte[] binData) {             this.buffers.add(binData);             if (this.buffers.size() == this.reconPack.attachments) {                 Packet packet = Binary.reconstructPacket(this.reconPack,                         this.buffers.toArray(new byte[this.buffers.size()][]));                 this.finishReconstruction();                 return packet;             }             return null;         }" compose:Replacement merge: LineBased]
											[T -> finishReconstruction({FormalParametersInternal}) : MethodDecl "public void finishReconstruction () {             this.reconPack = null;             this.buffers = new ArrayList<byte[]>();         }" compose:Replacement merge: LineBased]
